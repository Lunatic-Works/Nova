@<|
label('tut01', '教程1 文字与脚本结构')
is_unlocked_start()
|>
<|
set_box()
|>
教程1 文字与脚本结构

看这些教程的时候，最好把Unity里的运行情况与Scenarios文件夹里的脚本对照着看

如果哪一步没有看清，可以随时在文本回顾界面中跳回到之前的位置

写在这里的文字会在游戏里显示出来

想要点击鼠标显示下一段文字，就要在两段文字之间空一行


多空几行也不是不行，但是会让脚本比较难看

如果没有空行
就会把两行文字一起显示出来

想要在一起显示的文字当中加空行
<noparse></noparse>
可以用一个空的XML标记（教程4会详细讲XML标记）

王二宫：：两个中文冒号用来分隔说话人的名字和说话的内容

张浅野::也可以用两个英文冒号

<|
print('111')
-- 这是Lua里的注释
|>
在文字的上面可以用`<| ... |>`插入一个Lua代码块。上面的代码会在Unity Editor的Console窗口中输出“111”

顺便说一句：：上面的代码块与文字之间没有空行。如果有空行的话……

<|
print('222')
|>

就是先点一下鼠标运行代码（同时对话框变成空的），再点一下鼠标显示文字

我们把两个空行之间的东西叫做一“条”对话（dialogue entry）。一条对话中可能有文本，也可能有代码

顺便说一句：：不管有没有角色在说话，我们都把它叫做一条“对话”
@<| jump_to 'tut01_2' |>

@<| label 'tut01_2' |>
一个游戏的脚本可以划分为许多个节点（node），每个节点里可以有许多条对话

每个节点的开头和结尾处各有一个提前代码块（eager execution block），语法为`@<| ... |>`

顺便说一句：：一条对话中的代码块其实叫做延迟代码块（lazy execution block）。提前代码块在parse脚本时执行，延迟代码块则在游戏过程中执行

<noparse><</noparse><noparse>|</noparse>和<noparse>@<</noparse><noparse>|</noparse>不能出现在一行文本的开头

一行文本的结尾不能出现<noparse>|</noparse><noparse>></noparse>

<noparse>：</noparse><noparse>：</noparse>和<noparse>:</noparse><noparse>:</noparse>不能出现在文本中

它们都是Nova脚本的保留字，如果一定要出现，可以用XML标记把它们拆开（因为Nova先来parse这些保留字，TextMeshPro再来parse XML）

节点开头的提前代码块当中必须有一个`label`函数，定义这个节点的名称

比如我们现在所在的节点的名称是`tut01_2`，上面那个节点的名称则是`tut01`

顺便说一句：：如果节点名称以`l_`开头，这个节点名称就是定义在局部的，只能在同一个文件中使用，其他文件中可以有同名的节点

顺便说一句：：比如`test_branch.txt`和`test_minigame.txt`里都有`l_a`等等节点

这里的“名称”是给程序内部使用的。我们还可以定义一个“显示名称”，在存档界面等地方显示给玩家看

比如上面那个节点的开头有`label('tut01', '教程1 文字与脚本结构')`，所以名称是`tut01`，显示名称则是“教程1 文字与脚本结构”

顺便说一句：：Lua中的函数如果只有一个参数，并且参数是string literal或者table constructor，那么函数的括号可以省略（详见[Lua官网](https://www.lua.org/pil/5.html)）

而这个节点的开头只有`label 'tut01_2'`，那么显示名称默认与（同一个文件中的）上面的节点相同

你可以在存档界面里看看这个节点的显示名称
@<| jump_to 'tut01_3' |>

@<|
label('tut01_3', '教程1的后半部分')
|>
现在我们又定义了一个节点，并且改变了显示名称，你可以在存档界面里看看

如果一段剧情比较长，可以把它拆成好几个节点，还可以放到好几个txt文件里

节点的名称必须各不相同，而显示名称可以相同，这样玩家就不会注意到脚本当中其实有好几个节点

节点开头的提前代码块当中，还需要定义开始位置，也就是这个节点会不会显示在章节选择界面里

`is_start`表示这个节点是开始位置，玩家在游戏中走到这个节点之后，开始位置就会在章节选择界面中解锁

`is_unlocked_start`表示这个节点是开始位置，而且一开始就解锁了

如果你不需要章节选择界面，可以只在一个节点中设置`is_unlocked_start`，其他节点中都不设置开始位置

而在节点结尾的提前代码块当中，一般要有一个`jump_to`函数，定义跳转到的节点的名称

如果剧情结束了，则要用`is_end`函数

顺便说一句：：至于选项怎么做，以后再讲

修改脚本之后，在游戏中按R可以重新加载脚本，而不用重新开始游戏

这个功能在Unity Editor里才有效，游戏打包出来之后就没有了

如果修改脚本之后运行游戏出现报错，一般是因为之前的存档和新的脚本不兼容。这时需要清空存档，在Unity Editor的上面的菜单中点击`Nova -> Clear Save Data`

在制作游戏时，增加新的脚本一般不需要清空存档，修改已有的脚本可能需要清空存档。游戏打包出来之后，玩家在正常情况下不会需要清空存档

如果你想试试修改Colorless的脚本，需要先删除英文版的脚本，否则中文与英文的脚本会对不上（详见[GitHub上面的使用说明](https://github.com/Lunatic-Works/Nova)）

教程1 文字与脚本结构 到此结束
@<| jump_to 'tut02' |>
